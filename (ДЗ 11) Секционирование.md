**Стек**

Virtual Box 7.2.4      
Ubuntu Server 25.10  
Характеристики ВМ    
RAM: 16GB    
CPU: 8 cores  
VDI(SSD): 200GB  
PostgreSQL 17  


Копируем тестовую БД с https://edu.postgrespro.ru/demo-20250901-3m.sql.gz  
<img width="935" height="119" alt="image" src="https://github.com/user-attachments/assets/7d354d37-f19b-499e-be36-2689e747faf7" />

Разархивируем и запускаем скрипт  
<img width="959" height="385" alt="image" src="https://github.com/user-attachments/assets/ffd78aaf-9ada-42c9-90ed-afb30aaecfd2" />

Проверяем наличие базы
<img width="1616" height="231" alt="image" src="https://github.com/user-attachments/assets/8cf78737-5f3c-4e59-ba1a-271c9ee9fba2" />



Анализ структуры данных:

Ознакомьтесь с таблицами базы данных, особенно с таблицами bookings, tickets, ticket_flights, flights, boarding_passes, seats, airports, aircrafts.
Определите, какие данные в таблице bookings или других таблицах имеют логическую привязку к диапазонам, по которым можно провести секционирование (например, дата бронирования, рейсы).



Выбор таблицы для секционирования:
Основной акцент делается на секционировании таблицы bookings. Но вы можете выбрать и другие таблицы, если видите в этом смысл для оптимизации производительности (например, flights, boarding_passes).
Обоснуйте свой выбор: почему именно эта таблица требует секционирования? Какой тип данных является ключевым для секционирования?

Выбираем таблицу tickets для секционирования т.к. она имеет наибольший размер  
*Также имеет смысл взять таблицу segments поскольку разница в объёме с tickets у них небольшая, а строчек при этом у segments значительно больше, но остановимся на tickets т.к. нам достаточно реализовать 1 секционирование*  <img width="519" height="310" alt="image" src="https://github.com/user-attachments/assets/9eeca979-6773-46e3-92c3-d306224da81d" />


Определение типа секционирования:
Определитесь с типом секционирования, которое наилучшим образом подходит для ваших данных:

По диапазону (например, по дате бронирования или дате рейса).
По списку (например, по пунктам отправления или по номерам рейсов).
По хэшированию (для равномерного распределения данных).


Создание секционированной таблицы:
Преобразуйте таблицу в секционированную с выбранным типом секционирования.
Например, если вы выбрали секционирование по диапазону дат бронирования, создайте секции по месяцам или годам.



Миграция данных:

Перенесите существующие данные из исходной таблицы в секционированную структуру.
Убедитесь, что все данные правильно распределены по секциям.



Оптимизация запросов:

Проверьте, как секционирование влияет на производительность запросов. Выполните несколько выборок данных до и после секционирования для оценки времени выполнения.
Оптимизируйте запросы при необходимости (например, добавьте индексы на ключевые столбцы).



Тестирование решения:
Протестируйте секционирование, выполняя несколько запросов к секционированной таблице.
Проверьте, что операции вставки, обновления и удаления работают корректно.



Документирование:

Добавьте комментарии к коду, поясняющие выбранный тип секционирования и шаги его реализации.
Опишите, как секционирование улучшает производительность запросов и как оно может быть полезно в реальных условиях.

Анализируем на основе с
SELECT 
    schemaname,
    relname AS table_name,
    pg_size_pretty(pg_total_relation_size(relid)) AS total_size,
    n_live_tup AS row_estimate
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(relid) DESC;

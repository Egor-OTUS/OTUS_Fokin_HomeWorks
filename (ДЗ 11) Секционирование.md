**Стек**

Virtual Box 7.2.4      
Ubuntu Server 25.10  
Характеристики ВМ    
RAM: 16GB    
CPU: 8 cores  
VDI(SSD): 200GB  
PostgreSQL 17  


Копируем тестовую БД с https://edu.postgrespro.ru/demo-20250901-3m.sql.gz  
<img width="935" height="119" alt="image" src="https://github.com/user-attachments/assets/7d354d37-f19b-499e-be36-2689e747faf7" />

Разархивируем и запускаем скрипт  
<img width="959" height="385" alt="image" src="https://github.com/user-attachments/assets/ffd78aaf-9ada-42c9-90ed-afb30aaecfd2" />

Проверяем наличие базы
<img width="1616" height="231" alt="image" src="https://github.com/user-attachments/assets/8cf78737-5f3c-4e59-ba1a-271c9ee9fba2" />

***Анализ структуры данных:
Ознакомьтесь с таблицами базы данных, особенно с таблицами bookings, tickets, ticket_flights, flights, boarding_passes, seats, airports, aircrafts.
Определите, какие данные в таблице bookings или других таблицах имеют логическую привязку к диапазонам, по которым можно провести секционирование (например, дата бронирования, рейсы).***
***Выбор таблицы для секционирования:  
Основной акцент делается на секционировании таблицы bookings. Но вы можете выбрать и другие таблицы, если видите в этом смысл для оптимизации производительности (например, flights, boarding_passes).
Обоснуйте свой выбор: почему именно эта таблица требует секционирования? Какой тип данных является ключевым для секционирования?***  

Выбираем таблицу tickets для секционирования т.к. она имеет наибольший размер  
*Также имеет смысл взять таблицу segments поскольку разница в объёме с tickets у них небольшая, а строчек при этом у segments значительно больше, но остановимся на tickets т.к. нам достаточно реализовать 1 секционирование*  <img width="519" height="310" alt="image" src="https://github.com/user-attachments/assets/9eeca979-6773-46e3-92c3-d306224da81d" />

Структура таблицы tickets  
<img width="614" height="558" alt="image" src="https://github.com/user-attachments/assets/19d51e06-9c70-41a6-a437-ba4457375141" />

***Определение типа секционирования:
Определитесь с типом секционирования, которое наилучшим образом подходит для ваших данных:
По диапазону (например, по дате бронирования или дате рейса).
По списку (например, по пунктам отправления или по номерам рейсов).
По хэшированию (для равномерного распределения данных).***

Просмотрев структуру таблицы tickets можно сделать вывод, что нам подходит секционирование по диапозону (RANGE)  
Подходящие поля для RANGE это ticket_no и book_ref  
Проверим количество уникальных строчек для каждых из этих полей, у одного book_ref может быть несколько ticket_no, а значит секционирование по book_ref даст нам больше производительности по сравнению с ticket_no в плане DML/DDL запросов когда в зап. Вдобабок book_ref будет проще в реализации в плане секционирование по сравению с ticket_no из-за своих значений.  
<img width="500" height="250" alt="image" src="https://github.com/user-attachments/assets/1685eb47-5006-4357-85db-9ce73998f6ce" />

***Создание секционированной таблицы:
Преобразуйте таблицу в секционированную с выбранным типом секционирования.
Например, если вы выбрали секционирование по диапазону дат бронирования, создайте секции по месяцам или годам.***

Создаем новую таблицу tickets1, сохраняем структуру tickets и указываем секционирование RANGE
<img width="492" height="379" alt="image" src="https://github.com/user-attachments/assets/604e21eb-050a-47f4-bd3e-f32d984ed71a" />

Создадим секции которые будут в себя включать все значения возможные значения из поля tickets
<img width="647" height="224" alt="image" src="https://github.com/user-attachments/assets/9ecda836-a76e-429c-9b8f-33d20c321729" />


***Миграция данных:
Перенесите существующие данные из исходной таблицы в секционированную структуру.
Убедитесь, что все данные правильно распределены по секциям.***

Переносим данные   
<img width="334" height="53" alt="image" src="https://github.com/user-attachments/assets/3507a8a4-713e-44a8-8c73-8f32221bb0f6" />

Проверяем количество строк  
<img width="396" height="218" alt="image" src="https://github.com/user-attachments/assets/f403988d-b070-459b-ad3f-0c13fb6b9fb6" />

Проверим, что данные попали именно в свои диапазоны  
<img width="620" height="475" alt="image" src="https://github.com/user-attachments/assets/35fed0ba-4c9a-454c-a343-2c12c6a42414" />


***Оптимизация запросов:
Проверьте, как секционирование влияет на производительность запросов. Выполните несколько выборок данных до и после секционирования для оценки времени выполнения.
Оптимизируйте запросы при необходимости (например, добавьте индексы на ключевые столбцы).***

Сделаем простой Select запрос в каждой из таблиц, видим, что tickets1 выполняет запрос хуже tickets, все потому что у таблицы tickets1 нет индексов, а у таблицы tickets есть
<img width="899" height="293" alt="image" src="https://github.com/user-attachments/assets/bcaa847f-2c58-4795-a04b-530216c31b57" />

Добавим по простому индексу в каждую из наших новых таблиц
<img width="712" height="164" alt="image" src="https://github.com/user-attachments/assets/17b42f32-0c24-4322-acb1-07860ce5c2d6" />

Повторное применение explain после индексов, видим, что теперь мы ускорели скорость выполения запроса  
<img width="1212" height="420" alt="image" src="https://github.com/user-attachments/assets/f5111801-6759-490d-b2cc-bdb6e202f93f" />

Выполним еще explain запрос, который относится уже к другой секции, успешно, выиграли по времени  
<img width="1240" height="379" alt="image" src="https://github.com/user-attachments/assets/ae4dc7b5-841f-4a80-964a-313bf30f185a" />



***Тестирование решения:
Протестируйте секционирование, выполняя несколько запросов к секционированной таблице.
Проверьте, что операции вставки, обновления и удаления работают корректно.***



***Документирование:
Добавьте комментарии к коду, поясняющие выбранный тип секционирования и шаги его реализации.
Опишите, как секционирование улучшает производительность запросов и как оно может быть полезно в реальных условиях.***
Комментарии были добавлены по мере решения,


-- Смотрим структуру БД
SELECT 
    schemaname,
    relname AS table_name,
    pg_size_pretty(pg_total_relation_size(relid)) AS total_size,
    n_live_tup AS row_estimate
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(relid) DESC;

-- Создаем таблицу tickets1 сохраняя структуру таблицы tickets
CREATE TABLE bookings.tickets1 (
    ticket_no TEXT NOT NULL,
    book_ref CHARACTER(6) NOT NULL,
    passenger_id TEXT NOT NULL,
    passenger_name TEXT NOT NULL,
    outbound BOOLEAN NOT NULL
) PARTITION BY RANGE (book_ref); -- указывем тип секционирования

-- Секция 1: начинаются с цифры (0–9
CREATE TABLE bookings.tickets1_part_digits PARTITION OF bookings.tickets1
    FOR VALUES FROM ('0') TO ('A');
	
-- Секция 2: A–G
CREATE TABLE bookings.tickets1_part_ag PARTITION OF bookings.tickets1
    FOR VALUES FROM ('A') TO ('H');
	
-- Секция 3: H–P
CREATE TABLE bookings.tickets1_part_hp PARTITION OF bookings.tickets1
    FOR VALUES FROM ('H') TO ('Q');
	
-- Секция 4: Q–Z 
CREATE TABLE bookings.tickets1_part_else PARTITION OF bookings.tickets1
    DEFAULT;  -- ловит всё, что не попало в предыдущие секции

    -- Переносим данные
    INSERT INTO bookings.tickets1
SELECT * FROM bookings.tickets;

-- Создаем индексы для наших таблиц
CREATE INDEX idx_tickets1_book_ref ON bookings.tickets1 (book_ref);
CREATE INDEX idx_tickets1_part_digits ON bookings.tickets1_part_digits (book_ref);
CREATE INDEX idx_tickets1_part_ag ON bookings.tickets1_part_ag (book_ref);
CREATE INDEX idx_tickets1_part_hp ON bookings.tickets1_part_hp (book_ref);
CREATE INDEX idx_tickets1_part_else ON bookings.tickets1_part_else (book_ref);


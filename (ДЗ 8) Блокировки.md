***Стек***    
Virtual Box 7.2.4  
Ubuntu Server 25.10  
Характеристики ВМ  
RAM: 16GB  
CPU: 8 cores  
VDI(SSD): 200GB  
PostgreSQL 17  

***Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.*** 

Настраиваем конфигурационный файл  
<img width="454" height="190" alt="image" src="https://github.com/user-attachments/assets/b039532d-5021-4428-a75a-4aba07b3b866" />

Создаем БД и таблицу  
<img width="614" height="133" alt="image" src="https://github.com/user-attachments/assets/af63e236-5c92-4889-8d46-301a30601875" />

Запускаем транзакцию в одной сессии, после чего запускаем транзакцию в другой сессии  
<img width="526" height="99" alt="image" src="https://github.com/user-attachments/assets/07aeb2b7-38fd-4bba-83e5-849bef3f9ff3" /> 

Смотрим журнал логов, видим транзакция с pid 2467 ждет транзакцию с pid 2506  
<img width="939" height="81" alt="image" src="https://github.com/user-attachments/assets/d2a9e2ed-ff01-4e99-b4c3-e17f6c3b3ba0" />  

***Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.***  

Создаем UPDATE запрос в 3 сессии  
<img width="526" height="99" alt="image" src="https://github.com/user-attachments/assets/07aeb2b7-38fd-4bba-83e5-849bef3f9ff3" /> 

Смотрим pg_locks  
<img width="1893" height="415" alt="image" src="https://github.com/user-attachments/assets/60e889b2-ac49-4020-a05b-c1d934f435bd" />

Что мы видим

1)locktype - тип блокируемого объекта  

relation — таблица, индекс, последовательность и др. объекты‑отношения;  
tuple — конкретная строка (кортеж) в таблице;  
transactionid — идентификатор транзакции (постоянный);  
virtualxid — виртуальный идентификатор транзакции  

2.database - OID базы данных, к которой относится объект блокировки  
Проверим, что OID действительно нашей тестовой БД locks   
<img width="376" height="134" alt="image" src="https://github.com/user-attachments/assets/a8d4dae7-b651-44d8-98c2-97be6f6b278a" />  

3.relation - OID отношения (таблицы, индекса и т. п.), являющегося целью блокировки

4.page - номер страницы в отношении, которая блокируется

0 — цель не страница 

5.tuple - это блокировка, удерживаемая или ожидаемая на конкретную строку в таблице 

6.virtualxid — виртуальный идентификатор транзакции  

имеет вид N/M, где  
N — номер серверного процесса (backend ID);  
M — порядковый номер транзакции внутри этого процесса  

7.transactionid - идентификатор транзакции, на которую установлена блокировка

8.classid - oid класса таблицы рекомендуемый для блокировки

9.objid - oid объекта таблицы рекомендуемый для блокировки

10.objsubindic = номер столбца рекомендуемый для блокировки внутри таблицы относительно classid и objid

11.virtualtransaction - виртуальный идентификатор транзакции, удерживающей или ожидающей блокировку

12.pid - персональний идентификатор серверного процесса, который удерживает блокировку или ожидает её получения

13.mode - название режима блокировки, удерживаемой или запрашиваемой процессом

AccessShareLock - возникает: при операциях чтения SELECT;  
RowExclusiveLock - возникает при изменении данных INSERT, UPDATE, DELETE;  
ShareLock - возникает при CREATE INDEX;  
ExclusiveLock - возникает при TRUNCATE

14.granted 

t — блокировка получена;
f — процесс ожидает получения блокировки (находится в очереди)

15.fastpath 

t — блокировка получена по «быстрому пути» (оптимизированный механизм для частых блокировок);
f — блокировка получена через основную таблицу блокировок

16.waitstart - время, когда процесс начал ожидать блокировку



***Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?***  
Привет

***Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?***  
Привет

***Задание со звездочкой*
Попробуйте воспроизвести такую ситуацию.***  
Привет

***Стек***    
Virtual Box 7.2.4  
Ubuntu Server 25.10  
Характеристики ВМ  
RAM: 16GB  
CPU: 8 cores  
VDI(SSD): 200GB  
PostgreSQL 17  

***Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.*** 

Настраиваем конфигурационный файл  
<img width="454" height="190" alt="image" src="https://github.com/user-attachments/assets/b039532d-5021-4428-a75a-4aba07b3b866" />  
<img width="478" height="47" alt="image" src="https://github.com/user-attachments/assets/8dafacb9-1847-46ee-945d-b03eb3447e3a" />  

Создаем БД и таблицу  
<img width="614" height="133" alt="image" src="https://github.com/user-attachments/assets/af63e236-5c92-4889-8d46-301a30601875" />

Запускаем транзакцию в одной сессии и удерживаем её, после чего запускаем транзакцию в другой сессии и она уже станет блокироваться т.к. будет ожидать выполнение транзакции в первой сессии
<img width="526" height="99" alt="image" src="https://github.com/user-attachments/assets/07aeb2b7-38fd-4bba-83e5-849bef3f9ff3" /> 

Смотрим журнал логов, видим транзакция с pid 2467 ждет транзакцию с pid 2506  
<img width="939" height="81" alt="image" src="https://github.com/user-attachments/assets/d2a9e2ed-ff01-4e99-b4c3-e17f6c3b3ba0" />  

***Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.***  

Создаем UPDATE запрос в 3 сессии  
<img width="526" height="99" alt="image" src="https://github.com/user-attachments/assets/07aeb2b7-38fd-4bba-83e5-849bef3f9ff3" /> 

Смотрим pg_locks  
<img width="1893" height="415" alt="image" src="https://github.com/user-attachments/assets/60e889b2-ac49-4020-a05b-c1d934f435bd" />

Что мы видим

**1.locktype** - тип блокируемого объекта  

relation — таблица, индекс, последовательность и др. объекты‑отношения;  
tuple — конкретная строка (кортеж) в таблице;  
transactionid — идентификатор транзакции (постоянный);  
virtualxid — виртуальный идентификатор транзакции  

**2.database** - OID базы данных, к которой относится объект блокировки  
Проверим, что OID действительно нашей тестовой БД locks   
<img width="376" height="134" alt="image" src="https://github.com/user-attachments/assets/a8d4dae7-b651-44d8-98c2-97be6f6b278a" />  

**3.relation** - OID отношения (таблицы, индекса и т. п.), являющегося целью блокировки

**4.page** - номер страницы в отношении, которая блокируется

0 — цель не страница 

**5.tuple** - это блокировка, удерживаемая или ожидаемая на конкретную строку в таблице 

**6.virtualxid** — виртуальный идентификатор транзакции  

имеет вид N/M, где  
N — номер серверного процесса (backend ID);  
M — порядковый номер транзакции внутри этого процесса  

**7.transactionid** - идентификатор транзакции, на которую установлена блокировка

**8.classid** - oid класса таблицы рекомендуемый для блокировки

**9.objid** - oid объекта таблицы рекомендуемый для блокировки

**10.objsubindic** = номер столбца рекомендуемый для блокировки внутри таблицы относительно classid и objid

**11.virtualtransaction** - виртуальный идентификатор транзакции, удерживающей или ожидающей блокировку

**12.pid** - персональний идентификатор серверного процесса, который удерживает блокировку или ожидает её получения

**13.mode** - название режима блокировки, удерживаемой или запрашиваемой процессом

AccessShareLock - возникает: при операциях чтения SELECT;  
RowExclusiveLock - возникает при изменении данных INSERT, UPDATE, DELETE;  
ShareLock - возникает при CREATE INDEX;  
ExclusiveLock - возникает при TRUNCATE

**14.granted** 

t — блокировка получена;  
f — процесс ожидает получения блокировки (находится в очереди)

**15.fastpath**

t — блокировка получена по «быстрому пути» (оптимизированный механизм для частых блокировок);  
f — блокировка получена через основную таблицу блокировок

**16.waitstart** - время, когда процесс начал ожидать блокировку

***Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?*** 

Завершаем текущие транзакции в каждой из 3 сессий  
<img width="127" height="37" alt="image" src="https://github.com/user-attachments/assets/6129ea77-18b6-47dd-b0f4-c8818411ddf2" />

В сеансе 1 блокируем строку 1  
<img width="448" height="83" alt="image" src="https://github.com/user-attachments/assets/ab0b0b5a-a67e-4513-94c9-d0053bc6351e" />

В сеансе 2 блокируем строку 2  
<img width="443" height="63" alt="image" src="https://github.com/user-attachments/assets/52404e11-5659-42e3-9131-7f3b79f8e619" />

В сеансе 3 блокируем строку 3  
<img width="448" height="68" alt="image" src="https://github.com/user-attachments/assets/d67c29ae-ac81-42b8-a29c-bf57b7637466" />

В сеансе 1 пытаемся обновить строку 2, повисает
<img width="454" height="30" alt="image" src="https://github.com/user-attachments/assets/1e5695fe-7d77-41d4-9ace-f80ca56b8d6a" />

В сеансе 2 пытаемся обновить строку 3, повисает 
<img width="451" height="29" alt="image" src="https://github.com/user-attachments/assets/83a2eb29-8ad6-4c8f-bf27-4d8867bb705f" />

В сеансе 3 пытаемся обновить строку 1, приходит deadlock  
<img width="692" height="132" alt="image" src="https://github.com/user-attachments/assets/96771317-5d70-49ee-a502-1ee65aa58628" />


Таким образом транзакции блокируют друг друга 


***Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?***  
Привет

***Задание со звездочкой*
Попробуйте воспроизвести такую ситуацию.***  
Привет
